<?php

class MalwareDomain
{
    private $API_KEY;
    private $filePath;
    private $fileIterationLimit = 480;
    private $requestData = array();
    private $requestUrls = array();
    private $domainsWithErrors = array();
    private $errorDomains = array();

    public function __construct($config)
    {
        $this->API_KEY = $config['api_key'];
        $this->filePath = $config['file.path'];
        $this->fileIterationLimit = isset($config['file.iterationLimit']) ? $config['file.iterationLimit'] : $this->fileIterationLimit;
        $this->requestData = $config['request.data'];
        $this->requestUrls = $config['request.urls'];
    }

    public function checkDomains()
    {
        if (!file_exists($this->filePath)) {
            return false;
        }
		
		$timeLimit = ini_get('max_execution_time');
		set_time_limit(0);
		
        $domains = array();
        $fileWithDomains = @fopen($this->filePath, "r");

        if (!$fileWithDomains) {
			set_time_limit($timeLimit);
			return false;
        }
		
		$counter= 1;
		while (($buffer = fgets($fileWithDomains)) !== false) {
			
			$counter++;
			$domains[] = trim($buffer);

			if ($counter % $this->fileIterationLimit == 0) {
				foreach ($domains as $domain) {
					$this->requestData['threatInfo']['threatEntries'][] = array('url' => $domain);
				}

				$domains = array();
				$this->checkGatheredDomains();
				$this->requestData['threatInfo']['threatEntries'] = array();
			}
		}

		if (feof($fileWithDomains) && ($counter < $this->fileIterationLimit || $counter % $this->fileIterationLimit !== 0)) {
			foreach ($domains as $domain) {
				$this->requestData['threatInfo']['threatEntries'][] = array('url' => $domain);
			}

			$domains = array();
			$this->checkGatheredDomains();
			$this->requestData['threatInfo']['threatEntries'] = array();
		} else {
			throw new Exception('An exception occurs while reading the file!');
		}

		fclose($fileWithDomains);
		set_time_limit($timeLimit);
		
		return true;
    }

    public function getDomainErrors($domain)
    {
        if (empty($domain)) {
           return false;
        }

        return $this->domainsWithErrors[$domain];
    }

    public function getDomainsWithErrors()
    {
        return $this->errorDomains;
    }

    public function getAllErrors()
    {
        return $this->domainsWithErrors;
    }

    public function addDomain($domains = array())
    {
        if (empty($domains)) {
            return false;
        }

        $file = fopen($this->filePath, 'a');
        foreach ($domains as $domain) {
            if (in_array($domain, $this->domainsWithErrors)) {
                continue;
            }

            fwrite($file, $domain . PHP_EOL);
        }

        fclose($file);
    }

    private function checkGatheredDomains()
    {
        $domains = $this->request('find');

        if (count($domains->matches) > 0) {
            foreach ($domains->matches as $match) {

				if (!isset($this->domainsWithErrors[$match->threat->url]['types'])) {
					$this->domainsWithErrors[$match->threat->url]['types'] = array();
				}
				
				if (!isset($this->domainsWithErrors[$match->threat->url]['caches'])) {
					$this->domainsWithErrors[$match->threat->url]['caches'] = array();
				}
				
				if (!isset($this->domainsWithErrors[$match->threat->url]['platforms'])) {
					$this->domainsWithErrors[$match->threat->url]['platforms'] = array();
				}
				
                $a = array_search($match->threatType, $this->domainsWithErrors[$match->threat->url]['types']);
                $b = array_search($match->cacheDuration, $this->domainsWithErrors[$match->threat->url]['caches']);
                $c = array_search($match->platformType, $this->domainsWithErrors[$match->threat->url]['platforms']);

                if ($a == $b && $b == $c) {
                    if (!(isset($this->domainsWithErrors[$match->threat->url]['types'][$a]) &&
                        isset($this->domainsWithErrors[$match->threat->url]['caches'][$b]) &&
                        isset($this->domainsWithErrors[$match->threat->url]['platforms'][$c]) &&
                        $this->domainsWithErrors[$match->threat->url]['types'][$a] == $match->threatType &&
                        $this->domainsWithErrors[$match->threat->url]['caches'][$b] == $match->cacheDuration &&
                        $this->domainsWithErrors[$match->threat->url]['platforms'][$c] == $match->platformType)
                    ) {
                        $this->domainsWithErrors[$match->threat->url]['types'][] = $match->threatType;
                        $this->domainsWithErrors[$match->threat->url]['caches'][] = $match->cacheDuration;
                        $this->domainsWithErrors[$match->threat->url]['platforms'][] = $match->platformType;
                    }
                }

                if (!in_array($match->threat->url, $this->errorDomains)) {
                    $this->errorDomains[] = $match->threat->url;
                }
            }
        }

        return $this->domainsWithErrors;
    }

    private function request($action)
    {
        $ch = curl_init();

        $url = $this->requestUrls[$action];
        $url .= '?key=' . $this->API_KEY;

        $body = json_encode($this->requestData);

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', 'Content-Length: ' . strlen($body)));
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_VERBOSE, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $body);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);

        $result = curl_exec($ch);
        curl_close($ch);

        return json_decode($result);
    }
}